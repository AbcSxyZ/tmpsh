# Personnal test
# <  echo ~ ~te~st" ~ '$USER  \""+\\$USER+$US\ER~$USERS' ~ t"e$USER \'~'' ""'`' ""' \' ""'" \'>
# <echo "test>
# <echo test\ {ENTER} ' {ENTER} test {ENTER} '>
# <echo 'test\'.
# echo tes't $USER te'st
# echo tes"t $USER te"st
# lancer minishell et <cd -> bash: cd: OLDPWD not set
# path avec lien <cd -L -L -P -L .>  --> pas de redi
# && <cd -L -P .> --> redi
# <mkdir test1> && <chmod 666 test1> && <cd test> --> Fail
# <mkdir test2> && <chmod 111 test2> && <cd test2> --> OK
# mkdir folder && cd folder && cd .. && rm -rf folder && cd -
# <cd \./> && pwd --> PWD et OLDPWD devrait avoir la meme valeur
# <cd \/.///> && env PWD && cd ..
# <cd ~///./folder//.//>
# cd ~bocal/Public --> {~} correspond à /Users et {~/} correpond à /Users/ythollete
# echo ~root
# cat * | ./minishell <-- pas a executer mais a protéger
# env -i ./minishell && unsetenv PATH && echo $HOME && cd ~
# ./minishell && unsetenv HOME && cd $random --> HOME not set
# ./minishell < "n'importe quel fichier"
# </> && <~> && </Users>
# ./minishell && ./minishell && ./minishell && CtrC && CtrlD && exit
# echo `ls\` --> ` && echo `ls\``
# echo "text" > file ; < file cat
# {echo test 1>/dev/ttys001 1>&2} --> la derniere redi est prit en compte et print test
# cat << EOF existing_file {ENTER} word1 {ENTER} EOF {ENTER}
# echo test >'&2' && cat "&2" --> fichier &2
# echo file > '&'
# {export tty=/dev/ttys001} {echo test > $tty} et car ttys001 recoit
# {echo test > "/dev/ttys001\\"} --> error avec {/dev/ttys001\\}
# echo test > file > /dev/ttys001 (le dernier est prit en compte mais file est créé)
# echo test > glob"{ENTER}file" --> test dans file {glob?file}
# echo test>file1>file2
# echo test>file1\>file2
# echo test>file1\\>file2
# echo test \22>&1 --> test 22 dans &1
# echo test > file_no_right
# echo test && {ENTER} \ {ENTER} \\ {ENTER} puis flèche du haut et histo == {echo test && \\}
# ; puis ;; (pas le meme msg d'erreur)
# {t &&} --> bquote
# >>>
# <!< { } - $?
# ls\ --> saut de ligne puis ls exec --> pas de saut de ligne dans l'histo
# mkdir ~/folder && cd ~/folder && chmod 111 ~/folder && ~/21sh/./21sh && echo file_not_found > file
# << EOF cat nofile ;; --> les EOF puis ;; puis erreur de cat
# ;; "test {ENTER} " --> les fermetures des quotes sont prio face au ;;
# echo test \1>/dev/ttys00\2 '1>/dev/ttys003' --> on envoi test et
# echo test > file && cat < file>>file2
# a=5 b=3 echo $a (variable local envoyé temporairement dans la cmd)
# echo test << "1" && test ; <<\2
# cat << "EO {ENTER} F" {ENTER} puis essayer de fermer
# heredoc puis Cltr-c et Ctrl-v
# cat <<t {ENTER} test {Ctrl-D} ->> heredoc stop mais test dans cat
# << \'"test"\\
# >oui<<EOF
# <<EOF<file_stdin
# <<EOF>file_stdout
# {test && w} et {test || w} --> test renvoi FAIL
# env -i env
# exit | ls --> ne doit pas exit
# setenv VAR file && echo no_var>'$VAR' && echo var>$VAR
# setenv VAR ambiguous_redirect > $VAR
# export VAR file && echo test >~/$VAR
# unsetenv $HOME && echo "pwd.h get the *pw_name" >~/file
# echo file_line > file && cat << EOF1 < file << EOF2 puis line1 \n EOF1 \n line2 \n EOF2 --> dernier element avec bash et en suivant l'ordre pour zsh
# exit 1arg 2arg --> no exit
# cat <&\2
# echo test >folder/unfind_folder/file
# echo test >&0
# echo test > file | cat -->stdou prio sur pipe
# echo test | cat < file --> file écrase le pipe
# exit 2>file
# exit | test
# exit 1 2 --> too many arg et pas d'exit
# exit t --> exit mais pas msg "numeric arg required"
# / et /tmp --> "Is directory"
# auteur
# ls doesnotexist . >/dev/null 2>&1 (rien) et ls doesnotexist . 2>&1 >/dev/null (no such file or..)
# /Users/ythollet/42h/42sh -->exec et ~/42/42sh -->exec et 42sh -->pas exec
# a="1'2{ENTER}3" --> echo $a = 1'2 3
# "no'var"=command_not_found
# a={te"st}|ENTER|" --> a=$'{test}\n'
# 1=pasok mais a1=ok
# a={test --> ouvrir l'accolade et l'a fermer
# alias ls="echo noprint" && \ls --> ls est exec
# ls && cat || ls --> Ctrl-Z de cat --> ls s'execute
# cat &
# cat + Ctrl-Z puis ls
# mkfifo fifo && cat < fifo et avec autre shell : ls > fifo
# mkfifo fifo && ls >> fifo et lire fifo
# lorsque fifo est déjà en lecture ou ecriture avec un autre shell --> print error msg
# ls && exit &
# pwd && exit && ls & --> pwd mais pas d'exit ni ls
# echo ${} | wc --> les 2 sont exec
# echo ${} || echo ok ; echo ok
# echo ${} &&/|| wc --> fail pas de wc
# ls | echo ${} | wc &
# voir les valeurs de retour d'exit selon http://www.tldp.org/LDP/abs/html/exitcodes.html
